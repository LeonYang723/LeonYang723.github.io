<!-- head ä¿æŒä¸è®Šï¼Œç•¥ -->
<body>
  <h2>ğŸ” è‡‰éƒ¨è¾¨è­˜é–€é–</h2>

  <div class="btn-container">
    <button id="connectBtn">ğŸ”— é€£æ¥ ESP32</button>
    <button id="identifyBtn" disabled>ğŸ§  é–‹å§‹è¾¨è­˜</button>
  </div>

  <div id="videoContainer">
    <video id="video" autoplay muted playsinline></video>
    <canvas id="overlay"></canvas>
  </div>

  <!-- åœ–è¡¨ä¸‹æ–¹åŠ ä¸Šç´€éŒ„è¡¨æ ¼ -->
  <div id="chartContainer">
    <canvas id="scoreChart"></canvas>
  </div>

  <div id="status">ğŸ“¦ è¼‰å…¥ä¸­...</div>

  <table id="logTable" border="1" style="margin-top:20px; max-width:360px; margin-inline:auto; border-collapse:collapse;">
    <thead>
      <tr style="background-color:#ccc;">
        <th>Index</th>
        <th>å°æ¯”ç…§ç‰‡</th>
        <th>ç›¸ä¼¼åº¦</th>
        <th>çµæœ</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <script>
    const video = document.getElementById("video");
    const canvas = document.getElementById("overlay");
    const ctx = canvas.getContext("2d");
    const statusEl = document.getElementById("status");
    const connectBtn = document.getElementById("connectBtn");
    const identifyBtn = document.getElementById("identifyBtn");
    const logTable = document.getElementById("logTable").querySelector("tbody");

    let UARTService;
    let knownDescriptors = [];
    let indexCounter = 1;
    const THRESHOLD = 0.4;

    const chart = new Chart(document.getElementById("scoreChart").getContext("2d"), {
      type: "line",
      data: {
        labels: [],
        datasets: [{
          label: "Similarity Score",
          data: [],
          borderColor: "blue",
          backgroundColor: "blue",
          pointRadius: 5,
          fill: false,
          tension: 0.3
        }]
      },
      options: {
        responsive: true,
        scales: {
          y: { beginAtZero: true, max: 1 },
          x: { title: { display: true, text: "Index" } }
        }
      }
    });

    async function loadModels() {
      statusEl.textContent = "ğŸ“¦ è¼‰å…¥æ¨¡å‹ä¸­...";
      await faceapi.nets.tinyFaceDetector.loadFromUri("./models");
      await faceapi.nets.faceLandmark68Net.loadFromUri("./models");
      await faceapi.nets.faceRecognitionNet.loadFromUri("./models");
      await loadReferenceFaces();
      statusEl.textContent = "âœ… æ¨¡å‹è¼‰å…¥å®Œæˆï¼";
    }

    async function loadReferenceFaces() {
      const labels = ["1", "2", "3", "4"];
      for (let label of labels) {
        const img = await faceapi.fetchImage(`./faces/${label}.jpg`);
        const detection = await faceapi
          .detectSingleFace(img, new faceapi.TinyFaceDetectorOptions({ inputSize: 224 }))
          .withFaceLandmarks()
          .withFaceDescriptor();
        if (detection) {
          knownDescriptors.push({ label, descriptor: detection.descriptor });
        }
      }
    }

    async function startVideo() {
      const stream = await navigator.mediaDevices.getUserMedia({ video: true });
      video.srcObject = stream;
      video.onloadedmetadata = () => {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        video.play();
        statusEl.textContent = "ğŸ“· æ”å½±æ©Ÿå·²å•Ÿå‹•";
      };
    }

    async function connectBLE() {
      const device = await navigator.bluetooth.requestDevice({
        acceptAllDevices: true,
        optionalServices: ["6e400001-b5a3-f393-e0a9-e50e24dcca9e"]
      });
      const server = await device.gatt.connect();
      UARTService = await server.getPrimaryService("6e400001-b5a3-f393-e0a9-e50e24dcca9e");
      identifyBtn.disabled = false;
      await startVideo();
    }

    async function identifyFace() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const result = await faceapi
        .detectSingleFace(video, new faceapi.TinyFaceDetectorOptions({ inputSize: 160 }))
        .withFaceLandmarks()
        .withFaceDescriptor();

      if (!result) {
        statusEl.textContent = "ğŸ˜• æ²’æœ‰åµæ¸¬åˆ°äººè‡‰";
        return;
      }

      const resized = faceapi.resizeResults(result, { width: canvas.width, height: canvas.height });
      const box = resized.detection.box;
      const shrinkRatio = 0.8;
      const offsetY = -box.height * 0.1;

      const descriptor = result.descriptor;
      const results = knownDescriptors.map(item => ({
        label: item.label,
        dist: faceapi.euclideanDistance(descriptor, item.descriptor)
      }));

      const min = results.sort((a, b) => a.dist - b.dist)[0];

      const color = min.dist < THRESHOLD ? "green" : "red";
      const drawBox = new faceapi.draw.DrawBox({
        x: box.x + box.width * (1 - shrinkRatio) / 2,
        y: box.y + offsetY + box.height * (1 - shrinkRatio) / 2,
        width: box.width * shrinkRatio,
        height: box.height * shrinkRatio
      }, { label: `${min.label}.jpg (${min.dist.toFixed(2)})`, boxColor: color });
      drawBox.draw(canvas);

      // æ›´æ–°åœ–è¡¨
      chart.data.labels.push(indexCounter);
      chart.data.datasets[0].data.push(min.dist);
      chart.update();

      // æ–°å¢è¡¨æ ¼åˆ—
      const row = logTable.insertRow();
      row.insertCell().innerText = indexCounter;
      row.insertCell().innerText = `${min.label}.jpg`;
      row.insertCell().innerText = min.dist.toFixed(4);
      row.insertCell().innerText = min.dist < THRESHOLD ? "æˆåŠŸ" : "å¤±æ•—";
      indexCounter++;

      // å‚³é€è‡³ ESP32
      const txChar = await UARTService.getCharacteristic(RX_UUID);
      if (min.dist < THRESHOLD) {
        await txChar.writeValue(new TextEncoder().encode("UNLOCK"));
        statusEl.textContent = `âœ… æˆåŠŸè¾¨è­˜ç‚º ${min.label}.jpg`;
      } else {
        await txChar.writeValue(new TextEncoder().encode("FAIL"));
        statusEl.textContent = "âŒ æ‹’çµ•é–‹é–";
      }
    }

    connectBtn.onclick = connectBLE;
    identifyBtn.onclick = identifyFace;
    loadModels();
  </script>
</body>
</html>
